<?hh // strict

namespace HackPack\HackMini\Container;

final class Builder {
  const string HEAD = <<<'Hack'
<?hh // strict

/**
 * This file is generated by invoking `hackmini commands:build`.
 * Do not manually edit this file.
 */

use HackPack\HackMini\Container\Exception\CircularDependency;

final class FactoryContainer
{
Hack;

  const string
    FOOT = <<<'Hack'
    private Set<string> $names = Set{};

    private function __build__<T>(string $name, (function(this):T) $factory) : T
    {
        if($this->names->contains($name)) {
            throw new CircularDependency($name, $this->names);
        }
        $this->names->add($name);
        $result = $factory($this);
        $this->names->remove($name);
        return $result;
    }
}
Hack;

  public function __construct(
    private \ConstVector<ParsedDefinition> $definitions,
  ) {}

  public function render(): string {
    return implode(
      PHP_EOL,
      (Vector {self::HEAD})->addAll(
        $this->definitions->map($d ==> $this->renderDefinition($d)),
      )->add(self::FOOT),
    );
  }

  private function renderDefinition(ParsedDefinition $definition): string {
    $name = ucfirst($definition['name']);
    $return = $definition['return'];

    $handler = $this->renderFactory($definition);

    return<<<Hack

    <<__Memoize>>
    public function get{$name}() : {$return}
    {
        return \$this->new{$name}();
    }

    public function new{$name}() : {$return}
    {
        return \$this->__build__('{$name}', {$handler});
    }

Hack;
  }

  private function renderFactory(ParsedDefinition $definition): string {
    $function = Shapes::idx($definition, 'function');
    if (is_string($function)) {
      return "fun('{$function}')";
    }

    $class = Shapes::idx($definition, 'class');
    $method = Shapes::idx($definition, 'method');

    if ($class === null || $method === null) {
      throw new \UnexpectedValueException(
        sprintf(
          'Service %s does not have a defined factory.',
          $definition['name'],
        ),
      );
    }

    return "class_meth('{$class}', '{$method}')";
  }

}
